<!DOCTYPE html><html lang="en">

<head>
    <meta charset="UTF-8">
    <title>a chess thing i made</title>

    <!-- libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css"
        crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --bg: #e6e6e6;
            --card-bg: #fefefe;
            --border: #141414;
            --heading: #111;
            --text: #222;
            --accent: #3b3b3b;
        }

        html,
        body {
            height: 100%;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            background: var(--bg);
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--text);
            overflow-x: hidden;
        }

        .app-wrapper {
            width: min(90vw, 560px);
            margin: 2.5rem auto 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .brand {
            align-self: center;
            display: flex;
            justify-content: center;
            margin: 0.1rem 0;
        }

        .brand-logo {
            width: clamp(270px, 67vw, 360px);
            height: auto;
            display: block;
        }

        h1 {
            margin: 0;
            font-size: clamp(2.25rem, 4vw, 2.75rem);
            color: var(--heading);
            text-align: center;
        }

        .setup-card {
            width: 100%;
            padding: 2.75rem clamp(1.5rem, 5vw, 3.5rem);
            border-radius: 24px;
            border: 3px solid var(--border);
            background: var(--card-bg);
            display: flex;
            flex-direction: column;
            gap: 2rem;
            box-shadow: 0 32px 55px rgba(0, 0, 0, 0.18);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .control-group label {
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 0.85rem;
        }

        .colour-choice-grid {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .colour-choice {
            flex: 1 1 110px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.45rem;
            border: 2px solid var(--border);
            border-radius: 16px;
            padding: 0.75rem;
            background: #f8f8f8;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .colour-choice img {
            width: 64px;
            height: 64px;
            object-fit: contain;
            padding: 0.5rem;
            border-radius: 50%;
            background: #fff;
            border: 3px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.18);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .colour-choice.active img {
            border-color: rgba(255, 255, 255, 0.85);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.25);
        }

        .colour-choice span {
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        .colour-choice.active {
            background: #1f1f1f;
            color: #fff;
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.18);
        }

        .colour-choice:focus-visible {
            outline: 3px solid rgba(0, 0, 0, 0.3);
            outline-offset: 3px;
        }

        select {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 0.85rem 1rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
            background: #f9f9f9;
        }

        select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
        }

        .slider-track {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .history-controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            justify-content: center;
        }

        .history-btn {
            padding: 0.6rem 1.25rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: #f2f2f2;
            font-size: 0.9rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .history-btn:not(:disabled):hover {
            background: #fff;
            transform: translateY(-1px);
        }

        .history-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .history-indicator {
            font-weight: 700;
            letter-spacing: 0.05em;
            font-size: 0.9rem;
        }

        .loading-message {
            font-weight: 600;
            letter-spacing: 0.04em;
            font-size: 1rem;
            text-align: center;
        }

        .toggle-group {
            display: flex;
            gap: 0.75rem;
        }

        .toggle-btn {
            flex: 1;
            padding: 0.85rem 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: #f8f8f8;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .toggle-btn.active {
            background: #1f1f1f;
            color: #fff;
            transform: translateY(-1px);
        }

        .toggle-summary {
            display: flex;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--accent);
            letter-spacing: 0.04em;
        }

        .toggle-summary .divider {
            opacity: 0.4;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 32px;
            padding: 0;
            border: none;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            background: linear-gradient(90deg, #111 0%, #555 100%);
            border-radius: 999px;
            box-shadow: inset 0 0 0 2px var(--border);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #fff;
            border: 3px solid var(--border);
            border-radius: 50%;
            cursor: pointer;
            margin-top: -9px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #fff;
            border: 3px solid var(--border);
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-track {
            height: 10px;
            background: linear-gradient(90deg, #111 0%, #555 100%);
            border-radius: 999px;
            box-shadow: inset 0 0 0 2px var(--border);
        }

        input[type="range"]::-moz-range-progress {
            height: 10px;
            background: linear-gradient(90deg, #111 0%, #555 100%);
            border-radius: 999px;
            box-shadow: inset 0 0 0 2px var(--border);
        }

        .range-output {
            font-weight: 700;
            text-align: right;
            letter-spacing: 0.05em;
        }

        .start-button {
            margin-top: 0.5rem;
            align-self: center;
            padding: 0.95rem 3rem;
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border-radius: 14px;
            border: 3px solid var(--border);
            background: linear-gradient(180deg, #f5f5f5 0%, #bdbdbd 100%);
            color: var(--heading);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.15);
        }

        .start-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }

        #game {
            display: none;
            width: min(90vw, 560px);
            margin: 2.5rem auto 1.5rem;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        #board {
            width: min(75vw, 75vh);
            height: min(75vw, 75vh);
            margin: 0;
            /* Prevent scrolling/panning on mobile when dragging pieces */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #board div[class*="square-"] {
            position: relative;
        }

        #board .click-source {
            box-shadow: inset 0 0 0 4px rgba(255, 206, 0, 0.85);
        }

        #board .move-target::after {
            content: '';
            position: absolute;
            width: 26%;
            height: 26%;
            border-radius: 50%;
            background: rgba(64, 64, 64, 0.85);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #board .move-target.capture::after {
            width: 70%;
            height: 70%;
            background: rgba(64, 64, 64, 0.15);
            border: 3px solid rgba(64, 64, 64, 0.85);
        }

        @media (max-width: 768px) {
            body {
                align-items: stretch;
            }

            #game {
                width: 100vw;
                margin: 0;
                padding: clamp(0.75rem, 3vw, 1.25rem) 0;
                min-height: 100vh;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: clamp(0.75rem, 3vw, 1.25rem);
            }

            #board {
                margin: 0;
            }

            #historyControls,
            #status,
            #streamingMessage {
                padding: 0 clamp(0.75rem, 4vw, 1.5rem);
                text-align: center;
            }
        }

        #status {
            font-size: 1.125rem;
            text-align: center;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background: #fff;
            margin: 10vh auto;
            padding: 1.25rem 1.5rem;
            border-radius: 12px;
            width: min(90vw, 420px);
            max-height: min(85vh, 520px);
            overflow-y: auto;
            position: relative;
            box-shadow: 0 24px 60px rgba(0, 0, 0, 0.3);
        }
        .modal-content .close {
            position: absolute;
            top: 0.5rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
        }

        @media (max-width: 600px) {
            .modal-content {
                margin: 6vh auto;
                padding: clamp(1rem, 4vw, 1.5rem);
                border-radius: 10px;
                width: min(94vw, 420px);
            }

            .modal-content .close {
                top: 0.35rem;
                right: 0.75rem;
            }
        }
    </style>
</head>

<body>
    <div class="app-wrapper">
        <div class="brand">
            <img class="brand-logo" src="assets/logo.png" alt="ChessCrunch">
        </div>
        <h1>Game Setup</h1>

        <div class="setup-card">
            <div class="controls">
                <div class="control-group">
                    <label for="playerColourRandom">Colour</label>
                    <div class="colour-choice-grid" role="radiogroup" aria-label="Choose your side">
                        <button type="button" class="colour-choice" data-value="white" aria-pressed="false">
                            <img src="assets/white.png" alt="Play as white">
                            <span>White</span>
                        </button>
                        <button type="button" class="colour-choice active" data-value="random" id="playerColourRandom" aria-pressed="true">
                            <img src="assets/random.png" alt="Random side icon">
                            <span>Random</span>
                        </button>
                        <button type="button" class="colour-choice" data-value="black" aria-pressed="false">
                            <img src="assets/black.png" alt="Play as black">
                            <span>Black</span>
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <label for="advantage">Starting position</label>
                    <div class="slider-track">
                        <input type="range" id="advantage" min="-12" max="12" value="0">
                        <div class="slider-labels">
                            <span>Disadvantage</span>
                            <span>Advantage</span>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label for="elo">Bot difficulty</label>
                    <select id="elo">
                        <option value="200">Shit</option>
                        <option value="400">Extremely easy</option>
                        <option value="600">Very easy</option>
                        <option value="800">Easy</option>
                        <option value="1100" selected>Moderate</option>
                        <option value="1400">Hard</option>
                        <option value="1600">Very hard</option>
                        <option value="1800">Extremely hard</option>
                        <option value="2000">Candidate Master</option>
                        <option value="2200">International Master</option>
                        <option value="2500">Grandmaster</option>
                        <option value="3000">God</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="minPlies">Game state</label>
                    <div class="toggle-group" role="radiogroup">
                        <button type="button" class="toggle-btn active" data-min="16" data-max="60" data-label="Mid-game">Mid-game</button>
                        <button type="button" class="toggle-btn" data-min="60" data-max="120" data-label="Late-game">Late-game</button>
                    </div>
                    <div class="toggle-summary">
                        <span id="minPliesValue">Mid-game</span>
                        <span class="divider">•</span>
                        <span id="maxPliesValue">16–60 moves</span>
                    </div>
                    <input type="hidden" id="minPlies" value="16">
                    <input type="hidden" id="maxPlies" value="60">
                </div>
            </div>

            <button id="generateBtn" class="start-button">Start Game</button>
        </div>
    </div>
    <!-- Error modal -->
    <div class="modal" id="errorModal">
        <div class="modal-content">
            <span class="close" id="modalClose">&times;</span>
            <p>Sorry, it doesn't appear we could connect to our servers - but you can still play against the bot!</p>
        </div>
    </div>

    <div id="game">
        <div class="brand" id="inGameBrand" style="display: none;">
            <img class="brand-logo" src="assets/logo.png" alt="ChessCrunch">
        </div>
        <div id="board" style="display: none;"></div>
        <p id="streamingMessage" class="loading-message" style="display: none;">Streaming positions... please hang tight</p>
        <div class="history-controls" id="historyControls" style="display: none;">
            <button type="button" class="history-btn" id="historyPrev" disabled>← Back</button>
            <span class="history-indicator" id="historyIndicator">Move 0 / 0</span>
            <button type="button" class="history-btn" id="historyNext" disabled>Forward →</button>
        </div>
        <p id="status" style="display: none;"></p>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        /* --------------------------------------------------
           Helper maps (depth, skill, randomness)
        -------------------------------------------------- */
        // track selected player color globally
        let playerColor = 'white';
        function depthForElo(elo) {
            // console.log('Elo:', elo);
            if (elo < 300) return 1;
            if (elo < 500) return 2;
            if (elo < 700) return 2;  // weakened from 3
            if (elo < 900) return 3;  // weakened from 4
            if (elo < 1100) return 4; // weakened from 5
            return 5; // weakened from 6 (1100–1319)
        }

        function skillForElo(elo) {
            // console.log('Elo:', elo);
            // Stockfish Skill Level 0‑20 (0 weakest)
            if (elo < 300) return 0;
            if (elo < 500) return 1;
            if (elo < 700) return 2;  // weakened from 3
            if (elo < 900) return 4;  // weakened from 5
            if (elo < 1100) return 6; // weakened from 8
            return 10; // weakened from 12 (1100–1319)
        }

        function randomChanceForElo(elo) {
            // console.log('Elo:', elo);
            if (elo < 300) return 0.8;  // 60 % random
            if (elo < 500) return 0.4;   // 30 %
            if (elo < 700) return 0.2;   // 10 % randomness for <700
            if (elo < 900) return 0.1;   // slight randomness for <900
            return 0; // ≥900 – deterministic
        }

        /* --------------------------------------------------
           DOM prep – hide board until started
        -------------------------------------------------- */
    document.getElementById('board').style.display = 'none';
    document.getElementById('status').style.display = 'none';
    const inGameBrand = document.getElementById('inGameBrand');
    const historyWrapper = document.getElementById('historyControls');
    const streamingMessage = document.getElementById('streamingMessage');
    const historyPrevBtn = document.getElementById('historyPrev');
    const historyNextBtn = document.getElementById('historyNext');
    const historyIndicator = document.getElementById('historyIndicator');
    const boardElement = document.getElementById('board');
    const minPliesInput = document.getElementById('minPlies');
    const maxPliesInput = document.getElementById('maxPlies');
    const minPliesValue = document.getElementById('minPliesValue');
    const maxPliesValue = document.getElementById('maxPliesValue');
    const gameStateButtons = document.querySelectorAll('.toggle-btn');
    const colourButtons = document.querySelectorAll('.colour-choice');
    const history = [];
    let isStreaming = false;
    let historyIndex = 0;
    let colourSelection = 'random';
    let selectedSquare = null;
    let legalMovesForSelection = [];

        function setGameState(button) {
            gameStateButtons.forEach(btn => btn.classList.toggle('active', btn === button));
            minPliesInput.value = button.dataset.min;
            maxPliesInput.value = button.dataset.max;
            minPliesValue.textContent = button.dataset.label;
            maxPliesValue.textContent = `${button.dataset.min}–${button.dataset.max} moves`;
        }

        gameStateButtons.forEach(btn => btn.addEventListener('click', () => setGameState(btn)));

        function updateHistoryControls() {
            if (!historyPrevBtn || !historyNextBtn || !historyIndicator) return;
            const total = history.length;
            historyPrevBtn.disabled = total <= 1 || historyIndex <= 0;
            historyNextBtn.disabled = total === 0 || historyIndex >= total - 1;
            historyIndicator.textContent = total ? `Move ${historyIndex + 1} / ${total}` : 'Move 0 / 0';
        }

        function resetHistory(initialFen) {
            history.length = 0;
            historyIndex = 0;
            if (initialFen) {
                history.push(initialFen);
                historyIndex = history.length - 1;
            }
            updateHistoryControls();
            clearHighlights();
        }

        function pushHistory(fen) {
            if (!fen) {
                updateHistoryControls();
                return;
            }
            const lastFen = history[history.length - 1];
            if (lastFen !== fen) {
                history.push(fen);
            }
            historyIndex = history.length - 1;
            updateHistoryControls();
            updateStatus();
        }

        function setColourSelection(value) {
            colourSelection = value;
            colourButtons.forEach(btn => {
                const isActive = btn.dataset.value === value;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-pressed', isActive.toString());
            });
        }

        colourButtons.forEach(btn => btn.addEventListener('click', () => setColourSelection(btn.dataset.value)));
        // initialize defaults
        if (gameStateButtons.length) {
            setGameState(gameStateButtons[0]);
        }
        if (colourButtons.length) {
            setColourSelection('random');
        }
        document.getElementById('advantage').value = document.getElementById('advantage').defaultValue;

        /* --------------------------------------------------
           Globals
        -------------------------------------------------- */
        const STOCKFISH_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.min.js';
        let engine, ready = false, currentElo = 1200;

        /* --------------------------------------------------
           Utility: send command & log to console
        -------------------------------------------------- */
        function sfSend(cmd) {
            console.log('%c[SEND] ' + cmd, 'color:#0a0');
            engine.postMessage(cmd);
        }

        /* --------------------------------------------------
           Inline form submission and API integration
        -------------------------------------------------- */
        document.getElementById('generateBtn').addEventListener('click', async () => {
            isStreaming = true;
            // set global player color (handle random)
            const selected = colourSelection;
            if (selected === 'random') {
                playerColor = Math.random() < 0.5 ? 'white' : 'black';
            } else {
                playerColor = selected;
            }
            const elo = parseInt(document.getElementById('elo').value, 10);
            const minPlies = parseInt(document.getElementById('minPlies').value, 10);
            const maxPlies = parseInt(document.getElementById('maxPlies').value, 10);
            
            // Validate min/max turns
            if (minPlies > maxPlies) {
                alert('Min turns cannot be greater than max turns!');
                return;
            }
            
            // calculate signed target from slider (-25 to +25) * 100, flip sign if playing black
            const adv = parseInt(document.getElementById('advantage').value, 10);
            let target = adv * 100 * (playerColor === 'white' ? 1 : -1);

            chess.reset();
            board.orientation(playerColor);
            board.position(chess.fen(), false);
            resetHistory(chess.fen());

            // hide controls container and show board
            const setupWrapper = document.querySelector('.app-wrapper');
            if (setupWrapper) setupWrapper.style.display = 'none';
            const gameShell = document.getElementById('game');
            if (gameShell) gameShell.style.display = 'flex';
            const boardEl = document.getElementById('board');
            if (boardEl) {
                boardEl.style.display = 'block';
                resizeBoard();
                centerBoard();
            }
            const statusEl = document.getElementById('status');
            if (statusEl) statusEl.style.display = 'none';
            if (streamingMessage) {
                streamingMessage.style.display = 'block';
                streamingMessage.textContent = 'Streaming positions... please hang tight';
            }
            if (historyWrapper) {
                historyWrapper.style.display = 'none';
                updateHistoryControls();
            }
            if (inGameBrand) inGameBrand.style.display = 'flex';

            try {
                // stream positions via WebSocket
                const BACKEND_HOST = window.__CHESSCRUNCH_BACKEND__ || window.location.host;
                const API_PREFIX = window.__CHESSCRUNCH_API_PREFIX__ || '/api';
                const wsProto = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
                const socketUrl = `${wsProto}${BACKEND_HOST}${API_PREFIX}/ws/generate_board`;
                const sock = new WebSocket(socketUrl);
                sock.onopen = () => sock.send(JSON.stringify({ target, elo, min_plies: minPlies, max_plies: maxPlies }));
                let first = true;
                sock.onmessage = e => {
                    const { fen } = JSON.parse(e.data);
                    chess.load(fen);
                    if (first) { board.orientation(playerColor); first = false; }
                    clearHighlights();
                    board.position(fen, true);
                    pushHistory(chess.fen());
                };
                sock.onclose = () => {
                    // after streaming, show next turn and start engine
                    isStreaming = false;
                    updateStatus();
                    startGameEngine();
                };
                sock.onerror = () => {
                    // show error modal and fallback
                    document.getElementById('errorModal').style.display = 'block';
                    isStreaming = false;
                    updateStatus();
                    startGameEngine();
                };
            } catch (err) {
                console.error(err);
                // on connection failure, show modal and allow engine-only play
                document.getElementById('errorModal').style.display = 'block';
                isStreaming = false;
                updateStatus();
                startGameEngine();
            }
        });

        // Function to start the game engine (extracted from original start button logic)
        function startGameEngine() {
            document.querySelector('.controls').style.display = 'none';
            const gameShell = document.getElementById('game');
            const boardEl = document.getElementById('board');
            if (gameShell) gameShell.style.display = 'flex';
            if (boardEl) {
                boardEl.style.display = 'block';
                resizeBoard();
                centerBoard();
            }
            if (inGameBrand) inGameBrand.style.display = 'flex';
            if (streamingMessage) streamingMessage.style.display = isStreaming ? 'block' : 'none';
            updateStatus();
            // status remains as set by onclose; engine hook will update once ready

            fetch(STOCKFISH_CDN, { mode: 'cors' })
                .then(r => r.text())
                .then(code => {
                    const blobURL = URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));
                    engine = new Worker(blobURL);
                    hookEngine();
                })
                .catch(err => alert('Failed to load Stockfish: ' + err));
        }

        /* --------------------------------------------------
           Boot engine (original logic moved to startGameEngine)
        -------------------------------------------------- */

        /* --------------------------------------------------
           Handle engine output
        -------------------------------------------------- */
        function hookEngine() {
            engine.onmessage = e => {
                const line = typeof e.data === 'string' ? e.data : e.data?.toString();
                console.log('%c[SF]   ' + line, 'color:#09f');

                if (line === 'uciok') {
                    applyStrength();
                    ready = true;
                    // engine moves when it's engine's turn (opposite of player's)
                    const engineTurn = playerColor === 'white' ? 'b' : 'w';
                    if (chess.turn() === engineTurn) moveEngine();
                    return;
                }

                if (line === 'readyok') return;

                if (line.startsWith('bestmove')) {
                    const best = line.split(' ')[1];
                    chess.move({ from: best.slice(0, 2), to: best.slice(2, 4), promotion: 'q' });
                    board.position(chess.fen());
                    pushHistory(chess.fen());
                    clearHighlights();
                }
            };
            sfSend('uci');
        }

        /* --------------------------------------------------
           Apply strength settings each time elo changes
        -------------------------------------------------- */
        function applyStrength() {
            const s = document.getElementById('status');

            // Always set skill level (exists in this build)
            const skill = currentElo >= 1320 ? 20 : skillForElo(currentElo);
            sfSend('setoption name Skill Level value ' + skill);

            if (currentElo >= 3000) {
                // Full engine strength
                sfSend('setoption name UCI_LimitStrength value false');
                s.textContent = 'Full engine strength';
            } else if (currentElo >= 1320) {
                // Limit engine to target Elo
                sfSend('setoption name UCI_LimitStrength value true');
                sfSend('setoption name UCI_Elo value ' + currentElo);
            } else {
                // lower Elo: skill+depth caps
                sfSend('setoption name UCI_LimitStrength value false');
            }
            sfSend('isready');
        }

        /* --------------------------------------------------
           Elo slider change handler
        -------------------------------------------------- */
        document.getElementById('elo').addEventListener('change', () => {
            currentElo = parseInt(document.getElementById('elo').value, 10);
            if (ready) applyStrength();
        });

        /* --------------------------------------------------
           Chessboard init
        -------------------------------------------------- */
        const chess = new Chess();
        const board = Chessboard('board', {
            draggable: true,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
            position: 'start',
            onDragStart,
            onDrop,
            onSnapEnd: () => board.position(chess.fen())
        });

        function resizeBoard() {
            requestAnimationFrame(() => board.resize());
        }

        function centerBoard(behavior = 'auto') {
            if (!boardElement || !window.matchMedia) return;
            if (window.matchMedia('(orientation: landscape)').matches) {
                boardElement.scrollIntoView({ behavior, block: 'center' });
            }
        }

        window.addEventListener('resize', resizeBoard);
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                resizeBoard();
                centerBoard('smooth');
            }, 160);
        });

        resizeBoard();

        function getSquareElement(square) {
            if (!boardElement) return null;
            return boardElement.querySelector(`[data-square="${square}"]`) ||
                boardElement.querySelector(`.square-${square}`);
        }

        function clearHighlights() {
            if (!boardElement) return;
            boardElement.querySelectorAll('.click-source').forEach(el => el.classList.remove('click-source'));
            boardElement.querySelectorAll('.move-target').forEach(el => {
                el.classList.remove('move-target');
                el.classList.remove('capture');
            });
            selectedSquare = null;
            legalMovesForSelection = [];
        }

        function highlightMoves(square) {
            const moves = chess.moves({ square, verbose: true });
            if (!moves.length) {
                clearHighlights();
                return;
            }

            clearHighlights();
            selectedSquare = square;
            legalMovesForSelection = moves;
            const originEl = getSquareElement(square);
            if (originEl) originEl.classList.add('click-source');

            moves.forEach(move => {
                const targetEl = getSquareElement(move.to);
                if (!targetEl) return;
                targetEl.classList.add('move-target');
                if (move.captured) targetEl.classList.add('capture');
            });
        }

        function handlePlayerMove(from, to, { updateBoard = true } = {}) {
            const move = chess.move({ from, to, promotion: 'q' });
            if (!move) {
                if (updateBoard) {
                    board.position(chess.fen(), true);
                }
                return false;
            }
            if (updateBoard) {
                board.position(chess.fen(), true);
            }
            pushHistory(chess.fen());
            clearHighlights();
            setTimeout(moveEngine, 200);
            return true;
        }

        function squareFromElement(element) {
            if (!element) return null;
            let current = element;
            while (current && current !== boardElement) {
                if (current.dataset && current.dataset.square) {
                    return current.dataset.square;
                }
                if (current.classList) {
                    for (const cls of current.classList) {
                        if (/^square-[a-h][1-8]$/.test(cls)) {
                            return cls.slice(-2);
                        }
                    }
                }
                current = current.parentElement;
            }
            return null;
        }

        if (boardElement) {
            boardElement.addEventListener('click', event => {
                if (isStreaming || chess.game_over()) {
                    clearHighlights();
                    return;
                }

                if (historyIndex !== history.length - 1) {
                    clearHighlights();
                    return;
                }

                const square = squareFromElement(event.target);
                if (!square) return;

                if (selectedSquare) {
                    const move = legalMovesForSelection.find(m => m.to === square);
                    if (move) {
                        handlePlayerMove(selectedSquare, square);
                        return;
                    }
                    const selectedPiece = chess.get(square);
                    if (selectedPiece && selectedPiece.color === chess.turn()) {
                        highlightMoves(square);
                        return;
                    }
                    clearHighlights();
                    return;
                }

                const piece = chess.get(square);
                if (piece && piece.color === chess.turn()) {
                    highlightMoves(square);
                } else {
                    clearHighlights();
                }
            });
        }

        resetHistory(chess.fen());
        updateStatus();
        updateHistoryControls();

        function showHistoryAt(index) {
            if (!history.length) return;
            const boundedIndex = Math.max(0, Math.min(index, history.length - 1));
            if (boundedIndex === historyIndex) return;
            historyIndex = boundedIndex;
            const fen = history[historyIndex];
            const isLatest = historyIndex === history.length - 1;
            clearHighlights();
            board.position(fen, true);
            updateStatus(isLatest ? null : fen);
            updateHistoryControls();
        }

        if (historyPrevBtn) {
            historyPrevBtn.addEventListener('click', () => showHistoryAt(historyIndex - 1));
        }

        if (historyNextBtn) {
            historyNextBtn.addEventListener('click', () => showHistoryAt(historyIndex + 1));
        }

        /* --------------------------------------------------
           Mobile touch handling - prevent page scrolling on board
        -------------------------------------------------- */
        function preventMobileScrolling() {
            const boardNode = document.getElementById('board');
            
            // Prevent default touch behaviors on the board
            boardNode.addEventListener('touchstart', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            boardNode.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            boardNode.addEventListener('touchend', function(e) {
                e.preventDefault();
            }, { passive: false });
        }

        // Apply mobile touch handling after a short delay to ensure board is rendered
        setTimeout(preventMobileScrolling, 100);

        /* --------------------------------------------------
           Drag callbacks
        -------------------------------------------------- */
        function onDragStart(src, piece) {
            clearHighlights();
            if (historyIndex !== history.length - 1) return false;
            if (chess.game_over()) return false;

            const pieceColor = piece[0];
            const turn = chess.turn();
            if ((turn === 'w' && pieceColor === 'b') || (turn === 'b' && pieceColor === 'w')) {
                return false;
            }

            highlightMoves(src);
        }

        function onDrop(src, tgt) {
            const success = handlePlayerMove(src, tgt, { updateBoard: false });
            if (!success) return 'snapback';
        }

        /* --------------------------------------------------
           Engine move logic with randomness
        -------------------------------------------------- */
        function moveEngine() {
            if (!ready || chess.game_over()) return;

            // Chance for a pure random move instead of engine search
            const randChance = randomChanceForElo(currentElo);
            if (Math.random() < randChance) {
                const moves = chess.moves();
                const pick = moves[Math.floor(Math.random() * moves.length)];
                chess.move(pick);
                board.position(chess.fen());
                pushHistory(chess.fen());
                clearHighlights();
                return;
            }

            sfSend('position fen ' + chess.fen());

            if (currentElo < 1320) {
                const depth = depthForElo(currentElo);
                sfSend('go depth ' + depth);
            } else {
                sfSend('go movetime 1000');
            }
        }

        /* --------------------------------------------------
           UI Status helper
        -------------------------------------------------- */
        function updateStatus(fenOverride = null) {
            const s = document.getElementById('status');
            if (!s) return;
            const context = fenOverride ? new Chess(fenOverride) : chess;
            const turn = context.turn() === 'b' ? 'Black' : 'White';
            let text = context.in_checkmate() ? `Game over – ${turn} is checkmated.` :
                context.in_stalemate() ? 'Game over – stalemate.' :
                    context.insufficient_material() ? 'Game over – insufficient material (draw).' :
                        context.in_draw() ? 'Game over – draw.' :
                            `${turn} to move${context.in_check() ? `, ${turn} in check!` : ''}`;

            const viewingHistory = fenOverride !== null || historyIndex !== history.length - 1;
            if (viewingHistory && history.length) {
                text += ` — Viewing move ${historyIndex + 1} of ${history.length} (history view)`;
            }

            if (isStreaming) {
                s.style.display = 'none';
                if (historyWrapper) historyWrapper.style.display = 'none';
                if (streamingMessage) {
                    streamingMessage.style.display = 'block';
                    streamingMessage.textContent = 'Streaming positions... please hang tight';
                }
                return;
            }

            if (streamingMessage) streamingMessage.style.display = 'none';
            s.style.display = 'block';
            s.textContent = text;
            if (historyWrapper) {
                historyWrapper.style.display = history.length > 1 ? 'flex' : 'none';
            }
        }

        // Close error modal when X clicked
        const modal = document.getElementById('errorModal');
        const closeBtn = document.getElementById('modalClose');
        closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
        // Optionally close when clicking outside content
        window.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
    }); // end DOMContentLoaded
    </script>
</body>

</html>